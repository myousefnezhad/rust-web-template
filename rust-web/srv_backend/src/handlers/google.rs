use crate::AppState;
use actix_web::{get, http::StatusCode, web, HttpRequest, HttpResponse, Responder};
use askama::Template;
use chrono::{Duration, Utc};
use lib_crypto::jwt::{generate_token, Algorithm, Claims, RedisInfo};
use lib_error::http::ResponseError;
use lib_redis::Redis;
use log::*;
use rand::Rng;
use serde::Deserialize;

#[get("/google/auth")]
pub async fn get_google_auth(
    _req: HttpRequest,
    state: web::Data<AppState>,
) -> Result<impl Responder, ResponseError> {
    let config = state.app_config.clone();
    let auth_url = format!(
        "{}?client_id={}&redirect_uri={}&response_type=code&scope=openid%20email%20profile",
        &config.google_auth_url, &config.google_client_id, &config.google_redirect
    );
    warn!("{}", &auth_url);
    Ok(HttpResponse::Found()
        .append_header(("Location", auth_url))
        .finish())
}

/// Extract the query parameter (`code`) from Google’s callback URL.
/// (In a production app, you should also verify a `state` parameter.)
#[derive(Deserialize)]
struct AuthQuery {
    code: String,
}

/// Represents the JSON response from Google’s token endpoint.
#[derive(Deserialize)]
struct TokenResponse {
    access_token: String,
    // Other fields (id_token, expires_in, etc.) can be added as needed.
}

#[derive(Deserialize)]
struct UserInfo {
    _sub: Option<String>, // Unique identifier
    _name: Option<String>,
    _given_name: Option<String>,
    _family_name: Option<String>,
    _picture: Option<String>, // Profile image URL
    email: Option<String>,
    _email_verified: Option<bool>, // Whether email is verified
    _locale: Option<String>,
}

#[get("/google/callback")]
pub async fn get_google_callback(
    req: HttpRequest,
    state: web::Data<AppState>,
    query: web::Query<AuthQuery>,
) -> Result<impl Responder, ResponseError> {
    let config = state.app_config.clone();
    let redis = state.redis.clone();
    let jwt_access_key = config.jwt_access_key.clone();
    let jwt_access_session_min = config.jwt_access_session_min;
    let jwt_refresh_key = config.jwt_refresh_key.clone();
    let jwt_refresh_session_day = config.jwt_refresh_session_day;

    // GOOGLE USER PROCEDURE
    // Code generated by google
    let code = query.code.clone();
    // HTTP Client
    let client = reqwest::Client::new();

    // --- Step 1: Exchange the code for an access token ---
    let params = [
        ("code", code.as_str()),
        ("client_id", &config.google_client_id),
        ("client_secret", &config.google_client_secret),
        ("redirect_uri", &config.google_redirect),
        ("grant_type", "authorization_code"),
    ];

    let token_resp = client
        .post(&config.google_token_url)
        .form(&params)
        .send()
        .await;

    let token_resp = match token_resp {
        Ok(resp) => resp,
        Err(err) => {
            error!("Error sending token request: {}", err);
            return Err(ResponseError::new(
                "Token request failed".into(),
                StatusCode::INTERNAL_SERVER_ERROR,
                1,
            ));
        }
    };

    if !token_resp.status().is_success() {
        let text = token_resp.text().await.unwrap_or_default();
        error!("Token endpoint returned error: {}", text);
        return Err(ResponseError::new(
            "Token request failed".into(),
            StatusCode::INTERNAL_SERVER_ERROR,
            2,
        ));
    }

    let token: TokenResponse = match token_resp.json().await {
        Ok(t) => t,
        Err(err) => {
            error!("Error parsing token response: {}", err);
            return Err(ResponseError::new(
                "Failed to parse token response".into(),
                StatusCode::INTERNAL_SERVER_ERROR,
                3,
            ));
        }
    };

    // --- Step 2: Use the access token to fetch user info ---
    let userinfo_resp = client
        .get(&config.google_userinfo_url)
        .bearer_auth(&token.access_token)
        .send()
        .await;

    let userinfo_resp = match userinfo_resp {
        Ok(resp) => resp,
        Err(err) => {
            error!("Error sending userinfo request: {}", err);
            return Err(ResponseError::new(
                "Userinfo request failed".into(),
                StatusCode::INTERNAL_SERVER_ERROR,
                4,
            ));
        }
    };

    if !userinfo_resp.status().is_success() {
        let text = userinfo_resp.text().await.unwrap_or_default();
        error!("Userinfo endpoint returned error: {}", text);
        return Err(ResponseError::new(
            "Userinfo request failed".into(),
            StatusCode::INTERNAL_SERVER_ERROR,
            5,
        ));
    }

    // GOOGLE USER
    let user_info: UserInfo = match userinfo_resp.json().await {
        Ok(info) => info,
        Err(err) => {
            error!("Error parsing userinfo response: {}", err);
            return Err(ResponseError::new(
                "Failed to parse userinfo".into(),
                StatusCode::INTERNAL_SERVER_ERROR,
                6,
            ));
        }
    };
    let email = match &user_info.email {
        None => "Google email is not defined".into(),
        Some(email) => email.clone(),
    };

    // OUR APP TOKEN GENERATION

    // --- Step 3: Generate internal tokens and regular auth ---
    // Access Token
    let mut rng = rand::thread_rng();
    let session: u64 = rng.gen();
    let iat = Utc::now().timestamp();
    let exp = (Utc::now() + Duration::minutes(jwt_access_session_min)).timestamp();
    let access_claim = Claims {
        iat,
        exp,
        email: email.clone(),
        role: 0u64,
        session,
        source: "google".into(),
    };

    // Refresh Token
    let exp = (Utc::now() + Duration::days(jwt_refresh_session_day)).timestamp();
    let refresh_claim = Claims {
        iat,
        exp,
        email: email.clone(),
        role: 0u64,
        session,
        source: "google".into(),
    };

    // Generate Tokens
    let access_token = generate_token(Algorithm::HS256, &jwt_access_key, &access_claim)?;
    let refresh_token = generate_token(Algorithm::HS256, &jwt_refresh_key, &refresh_claim)?;

    // Saving Refresh Token in Redis
    let redis_key = format!("{}:{}", &email, &session);
    let forward_address = req
        .headers()
        .get("X-Forward-For")
        .and_then(|v| v.to_str().ok());
    let address = match forward_address {
        Some(ip) => format!("{}", ip),
        None => match req.peer_addr() {
            Some(ip) => format!("{}", ip),
            None => "Not Defined!".into(),
        },
    };
    let redis_info = RedisInfo {
        email: email.clone(),
        role: 0u64,
        session,
        address,
        browser: "google_auth".into(),
        token: refresh_token.clone(),
        source: "local".into(),
    };
    let redis_info_str = serde_json::to_string(&redis_info)?;
    let _ = Redis::set(&redis, &redis_key, &redis_info_str).await?;

    let url = format!("/google/token?token={} {}", access_token, refresh_token);

    // Redirect to Main Page
    Ok(HttpResponse::Found()
        .append_header(("Location", url))
        .finish())
}

#[derive(Template)]
#[template(path = "token.html")]
struct GoogleTokenPage;

#[get("/google/token")]
pub async fn page_google_token(
    _req: HttpRequest,
    _state: web::Data<AppState>,
) -> Result<impl Responder, ResponseError> {
    let page = GoogleTokenPage {};
    Ok(HttpResponse::Ok().body(page.render().unwrap()))
}
